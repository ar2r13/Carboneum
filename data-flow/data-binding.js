'use strict';function DataBinding(a){function b(k){if(3!==k.nodeType||!k.data.trim())return;const l=/(\(\(.+?\)\))/gim,m=k.data.split(l);if(1>=m.length)return;const n=k.parentNode||document.body,o=k.nextSibling;n&&(k.remove(),m.forEach((p)=>{const q=p.match(l),r=q?'':p,s=document.createTextNode(r);if(n.insertBefore(s,o),!r&&q){const t=g.get(this);if(!t)throw new ReferenceError(h);const u=t[q];Array.isArray(u)?u.push(s):t[q]=[s];const v=this.constructor.observedProperties;if(Array.isArray(v))for(let w;w=j.exec(q);)v.includes(w[1])&&this.observables.subscribe(w[1],()=>c.call(this,q))}}))}function c(k,l){const m=this.shadowRoot,n=g.get(this);if(!n)throw new ReferenceError(h);if(!m)return;const o=(p)=>{return l=null==l?e.call(this,p,k):l,l};n[k].forEach((p,q)=>{const r=null==o(p)?'':'object'==typeof l?JSON.stringify(l):l+'';m.contains(p)?p.data=r:this.stamps[k].splice(q,1)})}function d(k){const l=f.get(this);if(!Array.isArray(l))throw new ReferenceError('[WebComponent] Something went wrong. No stamps storage found.');for(let n=0;n<k.attributes.length;n++){const o=k.attributes[n],p=o.name,q=p.substr(0,2);if(!o.value.length||!['on','::'].includes(q))continue;const s=()=>{const u=e.call(this,k,o.value);switch(q){case'on':k[p]=(()=>'function'==typeof u?u.call(this,event,k):e.call(this,k,o.value)).bind(this);break;case'::':k.removeAttribute(p),k[p.substr(2)]=u;break;default:return;}},t=this.constructor.observedProperties;if(Array.isArray(t))for(let u;u=j.exec(o.value);)t.includes(u[1])&&this.observables.subscribe(u[1],s);l.push(s)}}function e(k,l){return new Function('$',`let v;with($){try{v=${l}}catch(e){console.error(e);return '['+e.name+']: '+e.message}return v}`).call(this,k)}const f=new WeakMap,g=new WeakMap,h='[WebComponent] Something went wrong. No stamps storage found.',j=/this[\.\[]+(\w+)/g;return class extends a{constructor(){super();const k=window.document.createNodeIterator(this.shadowRoot,NodeFilter.SHOW_ALL),l=[],m=[];for(let n;n=k.nextNode();)1===n.nodeType&&n.attributes.length&&l.push(n),3===n.nodeType&&n.data&&m.push(n);l.length&&(f.set(this,[]),l.forEach((o)=>d.call(this,o))),m.length&&(g.set(this,{}),m.forEach((o)=>b.call(this,o)))}connectedCallback(){const k=f.get(this);if(k){k.forEach((m)=>m());const l=g.get(this);l&&Object.keys(l).forEach((m)=>c.call(this,m))}}}}