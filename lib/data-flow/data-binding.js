'use strict';function dataBinding(a){function b(j){if(3!==j.nodeType||!j.data.trim())return;const k=/\[\[(.*::this[\.\[]+\w+.*)]]/gim,l=j.data.split(k);if(1>=l.length)return;const m=j.parentNode||document.body,n=j.nextSibling;m&&(j.remove(),l.forEach((o)=>{const p=o.replace(g,'this.$1'),q=p===o?o:'',r=document.createTextNode(q);if(m.insertBefore(r,n),!q&&p){const s=f.get(this);if(!s)throw new ReferenceError(h);const t=s[p];Array.isArray(t)?t.push(r):s[p]=[r];const u=this.constructor.observedProperties;if(Array.isArray(u)){let v;for(const w=/this[\.\[]+(\w+)/g;v=w.exec(p);)u.includes(v[1])&&this.observables.subscribe(v[1],()=>c.call(this,p))}}}))}function c(j,k){null==k&&(k=new Function(`return ${j}`).call(this));const l=this.shadowRoot,m=f.get(this);if(!m)throw new ReferenceError(h);l&&m[j].forEach((n,o)=>{const p=null==k?'':k+'';l.contains(n)?n.data=p:this.stamps[j].splice(o,1)})}function d(j){const k=e.get(this);if(!Array.isArray(k))throw new ReferenceError('[WebComponent] Something went wrong. No stamps storage found.');for(let m=0;m<j.attributes.length;m++){const n=j.attributes[m];if(!g.test(n.value))continue;const o=n.name,p=n.value.replace(g,'$.$1'),q=new Function('$',`
					function exp () {
						const value = ${p}
						return typeof value === 'function'
							? value.call($, event, this)
							: value
					}
					this.${o} = '${o}'.indexOf('on') === 0
						? exp
						: exp()
				`).bind(j),r=()=>q(this),s=this.constructor.observedProperties;if(Array.isArray(s)){let t;for(const u=/\$[\.\[]+(\w+)/g;t=u.exec(p);)s.includes(t[1])&&this.observables.subscribe(t[1],r)}k.push(r)}}const e=new WeakMap,f=new WeakMap,g=/::this[\.\[]+(\w+)/g,h='[WebComponent] Something went wrong. No stamps storage found.';return class extends a{constructor(){super();const j=window.document.createNodeIterator(this.shadowRoot,NodeFilter.SHOW_ALL),k=[],l=[];for(let m;m=j.nextNode();)1===m.nodeType&&m.attributes.length&&k.push(m),3===m.nodeType&&m.data&&l.push(m);k.length&&(e.set(this,[]),k.forEach((n)=>d.call(this,n))),l.length&&(f.set(this,{}),l.forEach((n)=>b.call(this,n)))}connectedCallback(){const j=e.get(this);if(j){j.forEach((l)=>l());const k=f.get(this);k&&Object.keys(k).forEach((l)=>c.call(this,l))}}}}